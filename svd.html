<!DOCTYPE html>
<html lang="en">
    <head>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.8.0/p5.min.js"></script>
        <meta charset="utf-8" />
    </head>
    <style>
        main {
            font-family: sans-serif;
            font-size: 2.5vh;
            line-height: 4vh;
            margin: 0 auto;
            max-width: 80%;
        }
        h1 {
            line-height: 6vh;
        }
        math {
            font-size: 2.65vh;
        }

        /* portrait tablets, portrait iPad, e-readers (Nook/Kindle), landscape 800x480 phones (Android) */ 
        @media (min-width:1025px)  {
            main {
                max-width: 55%;
            }
        }
    </style>
    <body>
        <main>
            <h1>Singular Value Decomposition</h1>
            <p>From Wikipedia: "In linear algebra, the <b>singular value decomposition (SVD)</b> is a factorization of a real or complex matrix into a <b>rotation</b>, followed by a <b>rescaling</b>, followed by <b>another rotation</b>."</p>
            <p>In other words, we <b>only need 3 matrices</b> to form any complex matrix. If we visualize this complex matrix as a linear transformation, we can see it as:</p>
            <math><mrow><mi>A</mi><mo>=</mo><msub><mi>R</mi><mi>2</mi></msub><mo>*</mo><mi>S</mi><mo>*</mo><msub><mi>R</mi><mi>1</mi></msub></mrow></math>
            <p>Here is a little interactive visualization of this observation in action - try and transform the white cube to fit the skewed grey shape with just the <b>rotation > scale > rotation</b> operations.</p>
            <p><b>Press keys WASD to scale, QE to rotate, and R to reset.</b></p>
            <p id="sketch-holder-1"></p>
            <div>
                <math>
                    <mrow>
                        <mi>A</mi><mo>=</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><mn>{{_tm[0][0]}}</mn></mtd>
                                <mtd><mn>{{_tm[0][1]}}</mn></mtd>
                                <mtd><mn>{{_tm[0][2]}}</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>{{_tm[1][0]}}</mn></mtd>
                                <mtd><mn>{{_tm[1][1]}}</mn></mtd>
                                <mtd><mn>{{_tm[1][2]}}</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>{{_tm[2][0]}}</mn></mtd>
                                <mtd><mn>{{_tm[2][1]}}</mn></mtd>
                                <mtd><mn>{{_tm[2][2]}}</mn></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                    </mrow>
                </math> 
            </div>
            <p>That is perhaps a tricky execerise, so if the point hasn't been brought across, here is the white cube transforming to fit the skewed grey shape by following a sequence of 3 matrix operations.</p>
            <div style="overflow: auto; scrollbar-width: none;">
                <math>
                    <mrow>
                        <mi>A</mi><mo>=</mo><msub><mi>R</mi><mi>2</mi></msub><mo>*</mo><mi>S</mi><mo>*</mo><msub><mi>R</mi><mi>1</mi></msub>
                        <mo>=</mo><mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><mn>cos(45°)</mn></mtd>
                                <mtd><mn>-sin(45°)</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>sin(45°)</mn></mtd>
                                <mtd><mn>cos(45°)</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>1</mn></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                        <mo>*</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><mn>1.5</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0.5</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>1</mn></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                        <mo>*</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><mn>cos(45°)</mn></mtd>
                                <mtd><mn>-sin(45°)</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>sin(45°)</mn></mtd>
                                <mtd><mn>cos(45°)</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>1</mn></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                    </mrow>
                </math> 
            </div>
            <p>Let us not worry about how the factorization into 3 matrices can be done yet. Instead, let us look into why SVD matters - because it exposes some interesting properties that can be used to solve a wide array of different problems!</p>
        </main>
        <script>
            // ==== START OF REACTIVE LIBRARY ====
            let listeners = [];

            document.querySelectorAll('body main *').forEach(element => {
                let rootNode = element.childNodes[0];
                if (!rootNode || !rootNode.nodeValue) return;
                let textContent = rootNode.textContent.trim();
                if (textContent.includes("\{\{") && textContent.includes("}}")) {
                    var variables = getHTMLInLineVariables(textContent);
                    if (variables.length === 0) return;
                    variablesValues = [];
                    variables.forEach(variable => variablesValues[variable] = undefined);
                    listeners.push({ element: rootNode, content: textContent, variables: variablesValues });
                }
            });

            function getHTMLInLineVariables(str) 
            { 
                let result = [];
                let openBracesIndex = -1;
                for(let i = 0; i < str.length; i++) { 
                    // If opening delimiter is encountered 
                    if (str.substring(i, i + 2) === "\{\{" && openBracesIndex === -1)
                        openBracesIndex = i;
                    // If closing delimiter is encountered 
                    else if (str.substring(i, i + 2) === "}}" && openBracesIndex > -1) {
                        let substring = str.substring(openBracesIndex + 2, i);
                        result.push(substring);
                        openBracesIndex = -1;
                    } 
                }
                return result;
            }

            function updateListeners(variableName, newValue) {
                let updatedListeners = [];
                listeners.forEach(listener => {
                    let isUpdated = false;
                    Object.keys(listener.variables).forEach(variableKey => {
                        let value = structuredClone(newValue);
                        let keysArray = getKeysArray(variableKey.trim());
                        if (keysArray[0] === variableName) {
                            if (keysArray.length > 1)
                                for(let i = 1; i < keysArray.length; i++)
                                    value = value[keysArray[i]];
                            isUpdated = true;
                            listener.variables[variableKey] = value;
                        }
                    });
                    if (isUpdated)
                        updatedListeners.push(listener);
                });
                updatedListeners.forEach(listener => {
                    let textContent = listener.content;
                    Object.keys(listener.variables).forEach(variableKey =>
                        textContent = textContent.replaceAll("\{\{" + variableKey + "}}", listener.variables[variableKey])
                    );
                    listener.element.textContent = textContent;
                });
            }

            function getKeysArray(str) {
                let results = [];
                let values = str.split(".");
                values.forEach(val => {
                    if (!val.includes("[")) results.push(val);
                    else val.split("[").forEach(val => results.push(val.replace("]", "")));
                });
                return results;
            }
            // ==== END OF REACTIVE LIBRARY ====

            function sketch1(p) {
                let _canvasWidth;
                let _tm = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]; // "transform matrix"
    
                updateListeners("_tm", fixDecimalPlaces(_tm, 2));
    
                p.setup = function() {
                    _canvasWidth = p.windowHeight > p.windowWidth ? p.windowWidth * 0.8 : p.windowWidth / 2;
                    let canvas = p.createCanvas(_canvasWidth, _canvasWidth * 9/16, p.WEBGL);
                    canvas.parent('sketch-holder-1');
                    p.angleMode(p.DEGREES);
                }
    
                p.windowResized = function() {
                    _canvasWidth = p.windowHeight > p.windowWidth ? p.windowWidth * 0.8 : p.windowWidth / 2;
                    p.resizeCanvas(_canvasWidth, _canvasWidth * 9/16);
                }
    
                p.draw = function() {
                    p.background(0);
                    
                    p.ortho();
                    
                    // Handle controls
                    let originalTm = _tm;
                    if (p.keyIsDown(65 + 18)) _tm = matrixMult(scaleMatrix(1, 0.989, 1), _tm);    // W
                    if (p.keyIsDown(65))      _tm = matrixMult(scaleMatrix(0.989, 1, 1), _tm);    // A
                    if (p.keyIsDown(65 + 22))  _tm = matrixMult(scaleMatrix(1, 1.01, 1), _tm);    // S
                    if (p.keyIsDown(65 + 3))  _tm = matrixMult(scaleMatrix(1.01, 1, 1), _tm);;    // D
                    if (p.keyIsDown(65 + 16)) _tm = matrixMult(zRotMatrix(2), _tm);               // Q
                    if (p.keyIsDown(65 + 4))  _tm = matrixMult(zRotMatrix(-2), _tm);              // E
                    // Reset with R key
                    if (p.keyIsDown(65 + 17)) {
                        _tm = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
                        setup();
                    }
                    if (originalTm != _tm) {
                        updateListeners("_tm", fixDecimalPlaces(_tm, 2));
                    }
                    
                    // Draw axes
                    
                    p.strokeWeight(3);
                    p.stroke(255, 0, 0);
                    p.fill(255); 
                    p.line(-_canvasWidth, 0, 0, _canvasWidth, 0, 0);
                    p.stroke(0, 255, 0);
                    p.line(0, -_canvasWidth, 0, 0, _canvasWidth, 0);
                    
                    // Draw target-box
                    p.push();
                    p.strokeWeight(4);
                    p.noFill();
                    p.stroke(111, 111, 111);
                    p.rotateZ(45);
                    p.scale(1.5, 0.5, 1);
                    p.rotateZ(45);
                    p.box(_canvasWidth / 4);
                    p.pop();
    
                    // Draw control-box
                    p.push();
                    p.strokeWeight(8);
                    p.noFill();
                    p.stroke(255, 255, 255);
                    p.applyMatrix(
                        _tm[0][0], _tm[0][1], _tm[0][2], _tm[0][3],
                        _tm[1][0], _tm[1][1], _tm[1][2], _tm[1][3],
                        _tm[2][0], _tm[2][1], _tm[2][2], _tm[2][3],
                        _tm[3][0], _tm[3][1], _tm[3][2], _tm[3][3],
                    );
                    p.box(_canvasWidth / 4);
                    p.pop();
                }
            }

            new p5(sketch1);

            // ==== START OF MATRIX LIBRARY ====

            function xRotMatrix(th) {
                return [
                    [1,     0,          0,          0],
                    [0,     cos(th),    -sin(th),   0],
                    [0,     sin(th),    cos(th),    0],
                    [0,     0,          0,          1]
                ];
            }

            function yRotMatrix(th) {
                return [
                    [cos(th),   0,      sin(th),    0],
                    [0,         1,      0,          0],
                    [-sin(th),  0,      cos(th),    0],
                    [0,         0,      0,          1]
                ];
            }

            function zRotMatrix(th) {
                return [
                    [cos(th),   -sin(th),   0,      0],
                    [sin(th),   cos(th),    0,      0],
                    [0,         0,          1,      0],
                    [0,         0,          0,      1]
                ];
            }

            function scaleMatrix(x, y, z) {
                return [
                    [x, 0, 0, 0], 
                    [0, y, 0, 0], 
                    [0, 0, z, 0], 
                    [0, 0, 0, 1]
                ];
            }

            function matrixMult(A, B) {
                if(A[0].length !== B.length) 
                    return "A col != B row"

                l = A.length;      // Number of rows in A
                m = A[0].length;   // Number of columns in A and number of rows in B
                n = B[0].length;   // Number of columns in B
                
                let C = []

                for(let i = 0; i < l; i++){
                    C[i] = [];
                    for(let j = 0; j < n; j++){
                        C[i][j] = [];
                    }
                }
                
                for(let row = 0; row < l ; row++){
                    for(let col = 0; col < n; col++){
                        let v = [];
                        let w = [];
                        for(let i = 0; i < m ; i++) {
                            v.push(A[row][i])
                            w.push(B[i][col])
                        }
                        C[row][col] = dotProduct(v,w)
                    }
                }
                return C;
            }

            function dotProduct(v, w) {
                let sum = 0;
                for (let i = 0; i < v.length; i++)
                    sum += v[i] * w[i];
                return sum;
            }

            function fixDecimalPlaces(mat, places) {
                let result = [];
                for(let row = 0; row < mat.length ; row++) {
                    result[row] = [];
                    for(let col = 0; col < mat[0].length; col++) {
                        result[row][col] = mat[row][col];
                        result[row][col] = result[row][col].toFixed(2);
                    }
                }    
                return result;
            }

            // ==== END OF MATRIX LIBRARY ====
        </script>
    </body>
</html>