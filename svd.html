<!DOCTYPE html>
<html lang="en">
    <head>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.8.0/p5.min.js"></script>
        <script src="components/top-nav-bar.js"></script>
        <link rel="stylesheet" href="style/main.css">
        <meta charset="utf-8" />
    </head>
    <body>
        <main>
            <top-nav-bar></top-nav-bar>
            <h1>Introduction to Singular Value Decomposition</h1>
            <p>Published: Dec 2024</p>
            <h2>Introducing SVD using linear transformations</h2>
            <p>
                From Wikipedia: "In linear algebra, the <b>singular value decomposition (SVD)</b> 
                is a factorization of a real or complex matrix into a <b>rotation</b>, 
                followed by a <b>rescaling</b>, followed by <b>another rotation</b>."
            </p>
            <p>
                In other words, we <b>only need 3 matrices</b> to form any complex matrix. 
                If we visualize this complex matrix as a linear transformation, we can see it as:
            </p>
            <math><mrow><mi>A</mi><mo>=</mo><msub><mi>R</mi><mi>2</mi></msub><mo>*</mo><mi>S</mi><mo>*</mo><msub><mi>R</mi><mi>1</mi></msub></mrow></math>
            <p>
                Here is a little interactive visualization of this observation in action - 
                try and transform the black square to fit the skewed grey shape with just the 
                <b>rotation > scale > rotation</b> operations.
            </p>
            <p><b>Press keys WASD to scale, QE to rotate, and R to reset.</b></p>
            <p id="sketch-holder-1"></p>
            <div>
                <math>
                    <mrow>
                        <mi>A</mi><mo>=</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><mn>{{_tm[0][0]}}</mn></mtd>
                                <mtd><mn>{{_tm[0][1]}}</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>{{_tm[1][0]}}</mn></mtd>
                                <mtd><mn>{{_tm[1][1]}}</mn></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                    </mrow>
                </math> 
            </div>
            <p>
                That is perhaps a tricky exercise, so if the point hasn't been brought across, 
                here is the black square transforming to fit the skewed grey shape by following 
                a sequence of 3 matrix operations.
            </p>
            <p id="sketch-holder-2"></p>
            <p>
                First, we shall rotate by <math><mrow><msub><mi>R</mi><mi>1</mi></msub></mrow></math> = 45°, 
                then we scale by <math><mrow><mi>S</mi></mrow></math> = (1.5, 0.1, 1.0), then we rotate again by 
                <math><mrow><msub><mi>R</mi><mi>2</mi></msub></mrow></math> = 45°. 
                This is represented by the following expression:
            </p>
            <div class="math-container">
                <math>
                    <mrow>
                        <mi>A</mi><mo>=</mo><msub><mi>R</mi><mi>2</mi></msub><mo>*</mo><mi>S</mi><mo>*</mo><msub><mi>R</mi><mi>1</mi></msub>
                        <mo>=</mo><mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><mn>cos(45°)</mn></mtd>
                                <mtd><mn>-sin(45°)</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>sin(45°)</mn></mtd>
                                <mtd><mn>cos(45°)</mn></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                        <mo>*</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><mn>1.5</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0.1</mn></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                        <mo>*</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><mn>cos(45°)</mn></mtd>
                                <mtd><mn>-sin(45°)</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>sin(45°)</mn></mtd>
                                <mtd><mn>cos(45°)</mn></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                    </mrow>
                </math> 
            </div>
            <p>Let us rewrite this as the <b>key expression</b> that is commonly used to describe the SVD of a matrix:</p>
            <div class="math-container">
                <math>
                    <mrow>
                        <mi>A</mi><mo>=</mo><mi>U</mi><mi>Σ</mi><msup><mi>V</mi><mi>T</mi></msup>
                        <mo>=</mo><mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><msub><mi>u</mi><mi>1</mi></msub></mtd>
                                <mtd><msub><mi>u</mi><mi>2</mi></msub></mtd>
                                <mtd><mn>...</mn></mtd>
                                <mtd><msub><mi>u</mi><mi>n</mi></msub></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                        <mo>*</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><msub><mi>σ</mi><mi>1</mi></msub></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd><msub><mi>σ</mi><mi>2</mi></msub></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd>...</mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd><msub><mi>σ</mi><mi>n</mi></msub></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                        <mo>*</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr><mtd><msup><msub><mi>v</mi><mi>1</mi></msub><mi>T</mi></msup></mtd></mtr>
                            <mtr><mtd><msup><msub><mi>v</mi><mi>2</mi></msub><mi>T</mi></msup></mtd></mtr>
                            <mtr><mtd><msup><mn>...</mn></mtd></mtr>
                            <mtr><mtd><msup><msub><mi>v</mi><mi>n</mi></msub><mi>T</mi></msup></mtd></mtr>
                        </mtable>
                        <mo>]</mo>
                    </mrow>
                </math>
            </div>
            <p>
                When we compare this with 
                <math><mrow><msub><mi>R</mi><mi>2</mi></msub><mo>*</mo><mi>S</mi><mo>*</mo><msub><mi>R</mi><mi>1</mi></msub></mrow></math>, 
                we see that <math><mrow><mi>U</mi></mrow></math> and <math><mrow><mi>V</mi></mrow></math> are orthonormal matrices, 
                i.e. it is made up of perpendicular unit vectors, or a set of linearly independent vectors that are 
                <math><mo>{</mo><msub><mi>u</mi><mi>1</mi></msub><mi>...</mi><msub><mi>u</mi><mi>n</mi></msub><mo>}</mo></math> and 
                <math><mo>{</mo><msub><mi>v</mi><mi>1</mi></msub><mi>...</mi><msub><mi>v</mi><mi>n</mi></msub><mo>}</mo></math>.
            </p>
            <p>
                And when we look at <math><mrow><mi>S</mi></mrow></math>, 
                we see that <math><mrow><mi>Σ</mi></mrow></math> 
                is a diagonal matrix that represents a "scaling" factor.
            </p>
            <p>
                Here's another way to look at this - let <math><mrow><mi>v</mi></mrow></math> 
                be a vector that we want to transform using the linear transformation 
                <math><mrow><mi>A</mi></mrow></math>. This is simply shown as:
            </p>
            <p><math><mrow><mi>A</mi><mi>v</mi><mo>=</mo><mi>x</mi></mrow></math></p>
            <p>If we split the resulting vector <math><mrow><mi>x</mi></mrow></math> as a scalar value with a unit vector, we shall get:</p>
            <p><math><mrow><mi>A</mi><mi>v</mi><mo>=</mo><mi>σ</mi><mi>u</mi></mrow></math></p>
            <p>Imagine that now instead of just transforming 1 vector, we are going to transform a series of vectors using this expression:</p>
            <div class="math-container">
                <math>
                    <mrow>
                        <mi>A</mi>
                        <mo>*</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><msub><mi>v</mi><mi>1</mi></msub></mtd>
                                <mtd><msub><mi>v</mi><mi>2</mi></msub></mtd>
                                <mtd><mn>...</mn></mtd>
                                <mtd><msub><mi>v</mi><mi>n</mi></msub></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                        <mo>=</mo><mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><msub><mi>u</mi><mi>1</mi></msub></mtd>
                                <mtd><msub><mi>u</mi><mi>2</mi></msub></mtd>
                                <mtd><mn>...</mn></mtd>
                                <mtd><msub><mi>u</mi><mi>n</mi></msub></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                        <mo>*</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><msub><mi>σ</mi><mi>1</mi></msub></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd><msub><mi>σ</mi><mi>2</mi></msub></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd>...</mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd><msub><mi>σ</mi><mi>n</mi></msub></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                    </mrow>
                </math>
            </div>
            <p>which can be re-arranged as</p>
            <p><math><mrow><mi>A</mi><mi>V</mi><mo>=</mo><mi>U</mi><mi>Σ</mi></mrow></math></p>
            <p><math><mrow><mi>A</mi><mo>=</mo><mi>U</mi><mi>Σ</mi><msup><mi>V</mi><mi>T</mi></msup></mrow></math></p>
            <p>But why does SVD matter? Because it exposes some interesting properties that can be used to solve a variety of problems!</p>
            <h2>Dimensionality Reduction and Data Compression</h2>
            <p>Consider this rank 1 matrix</p>
            <div class="math-container">
                <math>
                    <mrow>
                        <mi>A</mi><mo>=</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><mi>1</mi></mtd>
                                <mtd><mi>2</mi></mtd>
                                <mtd><mi>3</mi></mtd>
                                <mtd><mi>4</mi></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mi>-1</mi></mtd>
                                <mtd><mi>-2</mi></mtd>
                                <mtd><mi>-3</mi></mtd>
                                <mtd><mi>-4</mi></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mi>2</mi></mtd>
                                <mtd><mi>4</mi></mtd>
                                <mtd><mi>6</mi></mtd>
                                <mtd><mi>8</mi></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mi>10</mi></mtd>
                                <mtd><mi>20</mi></mtd>
                                <mtd><mi>30</mi></mtd>
                                <mtd><mi>40</mi></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                        <mo>=</mo>
                        <mo style="color:brown">[</mo>
                        <mtable style="color:brown">
                            <mtr><mtd><mi>1</mi></mtd></mtr>
                            <mtr><mtd><mi>-1</mi></mtd></mtr>
                            <mtr><mtd><mi>2</mi></mtd></mtr>
                            <mtr><mtd><mi>10</mi></mtd></mtr>
                        </mtable>
                        <mo style="color:brown">]</mo>
                        <mo>*</mo>
                        <mo style="color:cadetblue">[</mo>
                        <mtable style="color:cadetblue">
                            <mtr>
                                <mtd><mi>1</mi></mtd>
                                <mtd><mi>2</mi></mtd>
                                <mtd><mi>3</mi></mtd>
                                <mtd><mi>4</mi></mtd>
                            </mtr>
                        </mtable>
                        <mo style="color:cadetblue">]</mo>
                        <mo>=</mo><mi style="color:brown">u</mi><mo>*</mo><msup style="color:cadetblue"><mi>v</mi><mi>T</mi></msup>
                    </mrow>
                </math>
            </div>
            <p>
                This matrix is of rank = 1 because it only has 1 lineary independent column vector. 
                By decomposing this bigger matrix to 2 smaller ones <math style="color:brown"><mrow><mi>u</mi></mrow></math> and <math><mrow><msup style="color:cadetblue"><mi>v</mi><mi>T</mi></msup></mrow></math>, we represent the same matrix with less data (16 vs just 8 numbers!). 
                This becomes significant when we have a bigger, more complex matrix.
            </p>
            <p>
                Hence the idea is - when we factorize a complex matrix, we can compress the amount of data required to represent it! In this case, we have achieved lossless compression.
            </p>
            <p>
                Now imagine we have a higher ranked matrix A. 
                We cannot simply reduce it into a multiplication of 1 pair of row matrix and column matrix. 
                But what we can do is to <b>approximate</b> A by using a sum of ranked 1 matrices like so:
            </p>
            <p class="math-container">
                <math>
                    <mrow>
                        <mi>A</mi><mo>=</mo>
                        <msub><mi>σ</mi><mi>1</mi></msub><msub style="color:brown"><mi>u</mi><mi>1</mi></msub><msup style="color:cadetblue"><msub><mi>v</mi><mi>1</mi></msub><mi>T</mi></msup><mo>+</mo>
                        <msub><mi>σ</mi><mi>2</mi></msub><msub style="color:brown"><mi>u</mi><mi>2</mi></msub><msup style="color:cadetblue"><msub><mi>v</mi><mi>2</mi></msub><mi>T</mi></msup><mo>+</mo>
                        <mi>... ...</mi><mo>+</mo>
                        <msub><mi>σ</mi><mi>n</mi></msub><msub style="color:brown"><mi>u</mi><mi>n</mi></msub><msup style="color:cadetblue"><msub><mi>v</mi><mi>n</mi></msub><mi>T</mi></msup>
                    </mrow>
                </math>
            </p>
            <p class="math-container">
                <math>
                    <mrow>
                        <mo>=</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><msub style="color:brown"><mi>u</mi><mi>1</mi></msub></mtd>
                                <mtd><msub style="color:brown"><mi>u</mi><mi>2</mi></msub></mtd>
                                <mtd><mn style="color:brown">...</mn></mtd>
                                <mtd><msub style="color:brown"><mi>u</mi><mi>n</mi></msub></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                        <mo>*</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><msub><mi>σ</mi><mi>1</mi></msub></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd><msub><mi>σ</mi><mi>2</mi></msub></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd>...</mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd><msub><mi>σ</mi><mi>n</mi></msub></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                        <mo>*</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr><mtd><msup style="color:cadetblue"><msub><mi>v</mi><mi>1</mi></msub><mi>T</mi></msup></mtd></mtr>
                            <mtr><mtd><msup style="color:cadetblue"><msub><mi>v</mi><mi>2</mi></msub><mi>T</mi></msup></mtd></mtr>
                            <mtr><mtd><msup style="color:cadetblue"><mn>...</mn></mtd></mtr>
                            <mtr><mtd><msup style="color:cadetblue"><msub><mi>v</mi><mi>n</mi></msub><mi>T</mi></msup></mtd></mtr>
                        </mtable>
                        <mo>]</mo>
                    </mrow>
                </math>
            </p>
            <p><math><mrow><mo>=</mo><mi>U</mi><mi>Σ</mi><msup><mi>V</mi><mi>T</mi></msup></mrow></math></p>
            <p>Again, we arrive at the standard SVD expression.</p>
            <p>
                We see that <math><mi>Σ</mi></math> is a diagonal matrix consisting of scalar values "σ". These are known as <b>singular values</b>.
                Each of them represents the "scale of influence" of its respective <b>left singular vector</b> <math><mi>u</mi></math> and <b>right singular vector</b> <math><mi>v</mi></math>
                (i.e. a "singular vector pair").  
            </p>
            <p>
                In <math><mi>Σ</mi></math>, these singular values are arranged in descending order of magnitude. This means that the singular vector pairs 
                later in the sequence has less influence in approximating the complex matrix <math><mi>A</mi></math>.
            </p>
            <p>
                This is a helpful property of SVD, as that means we can remove singular vector pairs that has the 
                least influence (i.e. smallest singular values) in approximating <math><mi>A</mi></math>.
                This helps us achieve lossy compression with minimal information loss!
            </p>
            <p>
                In order to solidify this concept further, let us look at this interactive example that uses the same skewed parallelogram 
                we had. <b>Use the slider to play with different values of <math><msub><mi>σ</mi><mi>2</mi></msub></math> and see how it changes the shape.</b>
            </p>
            <p id="sketch-holder-3"></p>
            <p>
                <label><math><msub><mi>σ</mi><mi>1</mi></msub></math></label>
                <input type="range" min="0" max="100" value="100" class="slider" id="sketch-3-slide-s1">
                <label>{{s3Sigma[0][0]}}</label>
            </p>
            <p>
                <label><math><msub><mi>σ</mi><mi>2</mi></msub></math></label>
                <input type="range" min="0" max="100" value="100" class="slider" id="sketch-3-slide-s2">
                <label>{{s3Sigma[1][1]}}</label>
            </p>
            <p class="math-container">
                <math>
                    <mrow>
                        <mi>A</mi><mo>=</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><msub><mi>u</mi><mi>1</mi></msub></mtd>
                                <mtd><msub><mi>u</mi><mi>2</mi></msub></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                        <mo>*</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd style="color:brown"><mn><msub><mi>σ</mi><mi>1</mi></msub></mn></mtd>
                                <mtd><mn>0</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>0</mn></mtd>
                                <mtd style="color:brown"><mn><msub><mi>σ</mi><mi>2</mi></msub></mn></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                        <mo>*</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr><mtd><msup><msub><mi>v</mi><mi>1</mi></msub><mi>T</mi></msup></mtd></mtr>
                            <mtr><mtd><msup><msub><mi>v</mi><mi>2</mi></msub><mi>T</mi></msup></mtd></mtr>
                        </mtable>
                        <mo>]</mo>
                    </mrow>
                </math>
            </p>
            <p class="math-container">
                <math>
                    <mrow>
                        <mo>=</mo><mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><mn>cos(45°)</mn></mtd>
                                <mtd><mn>-sin(45°)</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>sin(45°)</mn></mtd>
                                <mtd><mn>cos(45°)</mn></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                        <mo>*</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd style="color:brown"><mn>{{s3Sigma[0][0]}}</mn></mtd>
                                <mtd><mn>0.00</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>0.00</mn></mtd>
                                <mtd style="color:brown"><mn>{{s3Sigma[1][1]}}</mn></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                        <mo>*</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><mn>cos(45°)</mn></mtd>
                                <mtd><mn>-sin(45°)</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>sin(45°)</mn></mtd>
                                <mtd><mn>cos(45°)</mn></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                    </mrow>
                </math>
            </p>
            <p class="math-container">
                <math>
                    <mrow>
                        <mo>=</mo><mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><mn>{{s3A[0][0]}}</mn></mtd>
                                <mtd><mn>{{s3A[0][1]}}</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>{{s3A[1][0]}}</mn></mtd>
                                <mtd><mn>{{s3A[0][1]}}</mn></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                    </mrow>
                </math>
            </p>
            <p>
                We can see that when <math><msub><mi>σ</mi><mi>2</mi></msub><mo>=</mo><mi>0</mi></math>, the 
                parallelogram is compressed into a line by removing the dimension that has the least variance.
            </p>
            <p>
                Compare that with reducing the value of <math><msub><mi>σ</mi><mi>1</mi></msub></math> and you will see that 
                adjusting the values of <math><msub><mi>σ</mi><mi>2</mi></msub></math> gets us a compression that is closer to the original graph,
                i.e. having the least information loss.
            </p>
            <p>
                Also note that the rank of <math><mi>Σ</mi></math> exposes the rank of A - we can see now that both the matrix
                <math><mi>Σ</mi></math> and the approximated matrix A went from <b>rank = 2</b> to <b>rank = 1</b> 
                (i.e. both matrices are made up of only 1 linearly independent column vector now). 
                This can be seen in how we turned a 2D parallelogram into a 1D line! This is known as <b>dimensionality reduction</b>.
            </p>
            <p>
                Let us now visualize this concept using this example of image compression.
                Adjust the "quality" slider to see how it changes the image!
            </p>
            <p id="sketch-holder-4"></p>
            <p>
                <label>Quality</label>
                <input type="range" min="0" max="10" value="10" class="slider" id="sketch-4-slide">
                <label>{{s4Slider}}</label>
            </p>
            <p class="math-container">
                <math style="font-size: 1.25vw;">
                    <mrow>
                        <mi>Σ</mi><mo>=</mo><mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><mi>{{s4s[0][0]}}</mi></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd><mi>{{s4s[1][1]}}</mi></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd><mi>{{s4s[2][2]}}</mi></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd><mi>{{s4s[3][3]}}</mi></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd><mi>{{s4s[4][4]}}</mi></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd><mi>{{s4s[5][5]}}</mi></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd><mi>{{s4s[6][6]}}</mi></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd><mi>{{s4s[7][7]}}</mi></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd><mi>{{s4s[8][8]}}</mi></mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd><mi>{{s4s[9][9]}}</mi></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                    </mrow>
                </math>
            </p>
            <p>
                In the image matrix, we can tell that out of 10 column vectors, there are only 5
                that are linearly independent. This is because the left half of the image is the same as the right half.
            </p>
            <p>
                Hence <math><mrow><mi>Σ</mi></mrow></math> and the image matrix are both of rank = 5 (the last 5 singular values σ are 0), i.e. 
                there is no change to the image when we adjust the "quality" slider between 50% - 100%. But the change to the image quality gets
                increasingly visible as the affected singular value gets bigger.
            </p>
            <h2>Finding correlations using SVD</h2>
            <h2>Solving linear systems</h2>
            <h2>Summary</h2>
            <p>1. All complex matrices can be factorized into 3 separate matrices using the SVD as such:</p>
            <p class="math-container">
                <math>
                    <mrow>
                        <mi>A</mi><mo>=</mo>
                        <msub><mi>σ</mi><mi>1</mi></msub><msub style="color:brown"><mi>u</mi><mi>1</mi></msub><msup style="color:cadetblue"><msub><mi>v</mi><mi>1</mi></msub><mi>T</mi></msup><mo>+</mo>
                        <msub><mi>σ</mi><mi>2</mi></msub><msub style="color:brown"><mi>u</mi><mi>2</mi></msub><msup style="color:cadetblue"><msub><mi>v</mi><mi>2</mi></msub><mi>T</mi></msup><mo>+</mo>
                        <mi>... ...</mi><mo>+</mo>
                        <msub><mi>σ</mi><mi>n</mi></msub><msub style="color:brown"><mi>u</mi><mi>n</mi></msub><msup style="color:cadetblue"><msub><mi>v</mi><mi>n</mi></msub><mi>T</mi></msup>
                    </mrow>
                </math>
            </p>
            <p class="math-container">
                <math>
                    <mrow>
                        <mo>=</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><msub style="color:brown"><mi>u</mi><mi>1</mi></msub></mtd>
                                <mtd><msub style="color:brown"><mi>u</mi><mi>2</mi></msub></mtd>
                                <mtd><mn style="color:brown">...</mn></mtd>
                                <mtd><msub style="color:brown"><mi>u</mi><mi>n</mi></msub></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                        <mo>*</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><msub><mi>σ</mi><mi>1</mi></msub></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd><msub><mi>σ</mi><mi>2</mi></msub></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd>...</mtd>
                                <mtd></mtd>
                            </mtr>
                            <mtr>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd></mtd>
                                <mtd><msub><mi>σ</mi><mi>n</mi></msub></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                        <mo>*</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr><mtd><msup style="color:cadetblue"><msub><mi>v</mi><mi>1</mi></msub><mi>T</mi></msup></mtd></mtr>
                            <mtr><mtd><msup style="color:cadetblue"><msub><mi>v</mi><mi>2</mi></msub><mi>T</mi></msup></mtd></mtr>
                            <mtr><mtd><msup style="color:cadetblue"><mn>...</mn></mtd></mtr>
                            <mtr><mtd><msup style="color:cadetblue"><msub><mi>v</mi><mi>n</mi></msub><mi>T</mi></msup></mtd></mtr>
                        </mtable>
                        <mo>]</mo>
                    </mrow>
                </math>
            </p>
            <p><math><mrow><mo>=</mo><mi>U</mi><mi>Σ</mi><msup><mi>V</mi><mi>T</mi></msup></mrow></math></p>
            <p>
                2. <math><mi>Σ</mi></math> is a diagonal matrix with "singular values" σ arranged in descending order of magnitude.
                They represent the scale of influence of corresponding singular vector pairs (<math><mi>u</mi></math>, <math><mi>v</mi></math>)
                found in the left and right singular matrices <math><mi>U</mi></math> and <math><msup><mi>V</mi><mi>T</mi></msup></math> respectively.
            </p>
            <p>
                3. <math><mi>Σ</mi></math> exposes the rank of <math><mi>A</mi></math>. We can reduce the rank / dimension 
                of <math><mi>A</mi></math> by setting a singular value σ to 0, which removes the corresponding singular vector pair (<math><mi>u</mi></math>, <math><mi>v</mi></math>) from the SVD.
            </p>
            <p>
                4. <math><mi>U</mi></math> and <math><mi>V</mi></math> are orthonormal matrices, i.e. each of them are made up of a set of 
                linearly independent vectors. Each corresponding singular vector pair (<math><mi>u</mi></math>, <math><mi>v</mi></math>)
                represents a dimension of the linear transformation <math><mi>A</mi></math>, or an implicit relationship or property 
                that describes the data matrix <math><mi>A</mi></math>.
            </p>
        </main>
        <script src="lib/ksdom_v0.1.js"></script>
        <script src="lib/ksmath_v0.1.js"></script>
        <script>
            /** SVD procedure as explained in "Singular Value Decomposition and Least Squares Solutions. By G.H. Golub et al."
             *
             * This procedure computes the singular values and complete orthogonal decomposition of a real rectangular matrix A:
             *    A = U * diag(q) * V(t), U(t) * U = V(t) * V = I
             * where the arrays a, u, v, q represent A, U, V, q respectively. The actual parameters corresponding to a, u, v may
             * all be identical unless withu = withv = {true}. In this case, the actual parameters corresponding to u and v must
             * differ. m >= n is assumed (with m = a.length and n = a[0].length)
             *
             *  @param a {Array} Represents the matrix A to be decomposed
             *  @param [withu] {bool} {true} if U is desired {false} otherwise
             *  @param [withv] {bool} {true} if U is desired {false} otherwise
             *  @param [eps] {Number} A constant used in the test for convergence; should not be smaller than the machine precision
             *  @param [tol] {Number} A machine dependent constant which should be set equal to B/eps0 where B is the smallest
             *    positive number representable in the computer
             *
             *  @returns {Object} An object containing:
             *    q: A vector holding the singular values of A; they are non-negative but not necessarily ordered in
             *      decreasing sequence
             *    u: Represents the matrix U with orthonormalized columns (if withu is {true} otherwise u is used as
             *      a working storage)
             *    v: Represents the orthogonal matrix V (if withv is {true}, otherwise v is not used)
             *
             */
            const SVD = (a, withu, withv, eps, tol) => {
                // Define default parameters
                withu = withu !== undefined ? withu : true
                withv = withv !== undefined ? withv : true
                eps = eps || Math.pow(2, -52)
                tol = 1e-64 / eps

                // throw error if a is not defined
                if (!a) {
                    throw new TypeError('Matrix a is not defined')
                }

                // Householder's reduction to bidiagonal form

                const n = a[0].length
                const m = a.length

                if (m < n) {
                    throw new TypeError('Invalid matrix: m < n')
                }

                let i, j, k, l, l1, c, f, g, h, s, x, y, z

                g = 0
                x = 0
                const e = []

                const u = []
                const v = []

                const mOrN = (withu === 'f') ? m : n

                // Initialize u
                for (i = 0; i < m; i++) {
                    u[i] = new Array(mOrN).fill(0)
                }

                // Initialize v
                for (i = 0; i < n; i++) {
                    v[i] = new Array(n).fill(0)
                }

                // Initialize q
                const q = new Array(n).fill(0)

                // Copy array a in u
                for (i = 0; i < m; i++) {
                    for (j = 0; j < n; j++) {
                        u[i][j] = a[i][j]
                    }
                }

                for (i = 0; i < n; i++) {
                    e[i] = g
                    s = 0
                    l = i + 1
                    for (j = i; j < m; j++) {
                        s += Math.pow(u[j][i], 2)
                    }
                    if (s < tol) {
                        g = 0
                    } else {
                        f = u[i][i]
                        g = f < 0 ? Math.sqrt(s) : -Math.sqrt(s)
                        h = f * g - s
                        u[i][i] = f - g
                        for (j = l; j < n; j++) {
                            s = 0
                            for (k = i; k < m; k++) {
                                s += u[k][i] * u[k][j]
                            }
                            f = s / h
                            for (k = i; k < m; k++) {
                                u[k][j] = u[k][j] + f * u[k][i]
                            }
                        }
                    }
                    q[i] = g
                    s = 0
                    for (j = l; j < n; j++) {
                        s += Math.pow(u[i][j], 2)
                    }
                    if (s < tol) {
                        g = 0
                    } else {
                        f = u[i][i + 1]
                        g = f < 0 ? Math.sqrt(s) : -Math.sqrt(s)
                        h = f * g - s
                        u[i][i + 1] = f - g
                        for (j = l; j < n; j++) {
                            e[j] = u[i][j] / h
                        }
                        for (j = l; j < m; j++) {
                            s = 0
                            for (k = l; k < n; k++) {
                                s += u[j][k] * u[i][k]
                            }
                            for (k = l; k < n; k++) {
                                u[j][k] = u[j][k] + s * e[k]
                            }
                        }
                    }
                    y = Math.abs(q[i]) + Math.abs(e[i])
                    if (y > x) {
                        x = y
                    }
                }

                // Accumulation of right-hand transformations
                if (withv) {
                    for (i = n - 1; i >= 0; i--) {
                        if (g !== 0) {
                            h = u[i][i + 1] * g
                            for (j = l; j < n; j++) {
                                v[j][i] = u[i][j] / h
                            }
                            for (j = l; j < n; j++) {
                                s = 0
                                for (k = l; k < n; k++) {
                                    s += u[i][k] * v[k][j]
                                }
                                for (k = l; k < n; k++) {
                                    v[k][j] = v[k][j] + s * v[k][i]
                                }
                            }
                        }
                        for (j = l; j < n; j++) {
                            v[i][j] = 0
                            v[j][i] = 0
                        }
                        v[i][i] = 1
                        g = e[i]
                        l = i
                    }
                }

                // Accumulation of left-hand transformations
                if (withu) {
                    if (withu === 'f') {
                        for (i = n; i < m; i++) {
                            for (j = n; j < m; j++) {
                                u[i][j] = 0
                            }
                            u[i][i] = 1
                        }
                    }
                    for (i = n - 1; i >= 0; i--) {
                        l = i + 1
                        g = q[i]
                        for (j = l; j < mOrN; j++) {
                            u[i][j] = 0
                        }
                        if (g !== 0) {
                            h = u[i][i] * g
                            for (j = l; j < mOrN; j++) {
                                s = 0
                                for (k = l; k < m; k++) {
                                    s += u[k][i] * u[k][j]
                                }
                                f = s / h
                                for (k = i; k < m; k++) {
                                    u[k][j] = u[k][j] + f * u[k][i]
                                }
                            }
                            for (j = i; j < m; j++) {
                                u[j][i] = u[j][i] / g
                            }
                        } else {
                            for (j = i; j < m; j++) {
                                u[j][i] = 0
                            }
                        }
                        u[i][i] = u[i][i] + 1
                    }
                }

                // Diagonalization of the bidiagonal form
                eps = eps * x
                let testConvergence
                for (k = n - 1; k >= 0; k--) {
                    for (let iteration = 0; iteration < 50; iteration++) {
                        // test-f-splitting
                        testConvergence = false
                        for (l = k; l >= 0; l--) {
                            if (Math.abs(e[l]) <= eps) {
                                testConvergence = true
                                break
                            }
                            if (Math.abs(q[l - 1]) <= eps) {
                                break
                            }
                        }

                        if (!testConvergence) { // cancellation of e[l] if l>0
                            c = 0
                            s = 1
                            l1 = l - 1
                            for (i = l; i < k + 1; i++) {
                                f = s * e[i]
                                e[i] = c * e[i]
                                if (Math.abs(f) <= eps) {
                                    break // goto test-f-convergence
                                }
                                g = q[i]
                                q[i] = Math.sqrt(f * f + g * g)
                                h = q[i]
                                c = g / h
                                s = -f / h
                                if (withu) {
                                    for (j = 0; j < m; j++) {
                                        y = u[j][l1]
                                        z = u[j][i]
                                        u[j][l1] = y * c + (z * s)
                                        u[j][i] = -y * s + (z * c)
                                    }
                                }
                            }
                        }

                        // test f convergence
                        z = q[k]
                        if (l === k) { // convergence
                            if (z < 0) {
                                // q[k] is made non-negative
                                q[k] = -z
                                if (withv) {
                                    for (j = 0; j < n; j++) {
                                        v[j][k] = -v[j][k]
                                    }
                                }
                            }
                            break // break out of iteration loop and move on to next k value
                        }

                        // Shift from bottom 2x2 minor
                        x = q[l]
                        y = q[k - 1]
                        g = e[k - 1]
                        h = e[k]
                        f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2 * h * y)
                        g = Math.sqrt(f * f + 1)
                        f = ((x - z) * (x + z) + h * (y / (f < 0 ? (f - g) : (f + g)) - h)) / x

                        // Next QR transformation
                        c = 1
                        s = 1
                        for (i = l + 1; i < k + 1; i++) {
                            g = e[i]
                            y = q[i]
                            h = s * g
                            g = c * g
                            z = Math.sqrt(f * f + h * h)
                            e[i - 1] = z
                            c = f / z
                            s = h / z
                            f = x * c + g * s
                            g = -x * s + g * c
                            h = y * s
                            y = y * c
                            if (withv) {
                                for (j = 0; j < n; j++) {
                                    x = v[j][i - 1]
                                    z = v[j][i]
                                    v[j][i - 1] = x * c + z * s
                                    v[j][i] = -x * s + z * c
                                }
                            }
                            z = Math.sqrt(f * f + h * h)
                            q[i - 1] = z
                            c = f / z
                            s = h / z
                            f = c * g + s * y
                            x = -s * g + c * y
                            if (withu) {
                                for (j = 0; j < m; j++) {
                                    y = u[j][i - 1]
                                    z = u[j][i]
                                    u[j][i - 1] = y * c + z * s
                                    u[j][i] = -y * s + z * c
                                }
                            }
                        }
                        e[l] = 0
                        e[k] = f
                        q[k] = x
                    }
                }

                // Number below eps should be zero
                for (i = 0; i < n; i++) {
                    if (q[i] < eps) q[i] = 0
                }

                // Added by KS: Sort q, u, v by descending order of singular values.
                // TODO: This is bubblesort. Please optimize using quicksort.
                for (let i = 0; i < q.length; i++) {
                    for (let j = 0; j < (q.length - i - 1); j ++) {
                        if (q[j] < q[j+1]) {
                            let temp = q[j]; 
                            q[j] = q[j + 1]; 
                            q[j + 1] = temp;
                            for (let row = 0; row < q.length; row ++) {
                                    temp = u[row][j]; u[row][j] = u[row][j + 1]; u[row][j + 1] = temp;
                                    temp = v[row][j]; v[row][j] = v[row][j + 1]; v[row][j + 1] = temp;
                            }
                        }
                    }
                }

                return { u, q, v }
            }
        </script>
        <script>
            function calculateCanvasWidth(p) {
                return Math.min(p.windowHeight > p.windowWidth ? p.windowWidth * 0.8 : p.windowWidth / 2, 700);
            }

            function sketch2(p) {
                let _canvasWidth;
                let _currentStep = 0;
                let _step1z = 0, _step2X = 1, _step2Y = 1, _step3z = 0;
                let timeout = undefined;

                p.setup = function() {
                    _canvasWidth = calculateCanvasWidth(p);
                    let canvas = p.createCanvas(_canvasWidth, _canvasWidth * 9/16, p.WEBGL);
                    canvas.parent('sketch-holder-2');
                    p.angleMode(p.DEGREES);
                }
    
                p.windowResized = function() {
                    _canvasWidth = calculateCanvasWidth(p);
                    p.resizeCanvas(_canvasWidth, _canvasWidth * 9/16);
                }

                p.draw = function() {
                    p.background(255);
                    p.ortho();
                    
                    // Draw axes
                    p.strokeWeight(5);
                    p.stroke(255, 0, 0);
                    p.fill(255); 
                    p.line(-_canvasWidth, 0, 0, _canvasWidth, 0, 0);
                    p.stroke(0, 255, 0);
                    p.line(0, -_canvasWidth, 0, 0, _canvasWidth, 0);
                    
                    // Draw target-box
                    p.push();
                    p.strokeWeight(5);
                    p.noFill();
                    p.stroke(200, 200, 200);
                    p.rotateZ(45);
                    p.scale(1.5, 0.1, 1);
                    p.rotateZ(45);
                    p.box(_canvasWidth / 4);
                    p.pop();

                    // Draw control box
                    p.push();
                    p.strokeWeight(8);
                    p.noFill();
                    p.stroke(0, 0, 0);

                    if(_currentStep === 0) {
                        if (_step1z === 45 ) _currentStep++;
                        else _step1z = Math.min(_step1z + 1, 45);
                    }

                    if (_currentStep === 1) {
                        if (_step2X === 1.5) _currentStep++;
                        else {
                            _step2X = Math.min(_step2X + 0.01, 1.5);
                            _step2Y = Math.max(_step2Y - 0.02, 0.1);
                        }
                    }
                    
                    if(_currentStep === 2) {
                        if (_step3z === 45 ) _currentStep++;
                        else _step3z = Math.min(_step3z + 1, 45);
                    }
                    
                    if (_currentStep === 3) {
                        p.stroke(0, 0, 255);
                        if (!timeout) {
                            timeout = setTimeout(() => {
                                _currentStep = 0;
                                _step1z = 0; _step2X = 1; _step2Y = 1; _step3z = 0;
                                timeout = undefined;
                            }, 2000);
                        }
                    }

                    p.rotateZ(_step1z);
                    p.scale(_step2X, _step2Y, 1);
                    p.rotateZ(_step3z);
                    p.box(_canvasWidth / 4);
                    p.pop();
                }
            }
            new p5(sketch1);

            function sketch1(p) {
                let _canvasWidth;
                let _tm = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]; // "transform matrix"
    
                KSDom.updateListeners("_tm", KSMath.Matrix.toFixed(_tm, 2));
    
                p.setup = function() {
                    _canvasWidth = calculateCanvasWidth(p);
                    let canvas = p.createCanvas(_canvasWidth, _canvasWidth * 9/16, p.WEBGL);
                    canvas.parent('sketch-holder-1');
                    p.angleMode(p.DEGREES);
                }
    
                p.windowResized = function() {
                    _canvasWidth = calculateCanvasWidth(p);
                    p.resizeCanvas(_canvasWidth, _canvasWidth * 9/16);
                }
    
                p.draw = function() {
                    p.background(255);
                    
                    p.ortho();
                    
                    // Handle controls
                    let originalTm = _tm;
                    if (p.keyIsDown(65 + 18)) _tm = KSMath.Matrix.multiply(KSMath.Matrix.scale(1, 0.989, 1), _tm);    // W
                    if (p.keyIsDown(65))      _tm = KSMath.Matrix.multiply(KSMath.Matrix.scale(0.989, 1, 1), _tm);    // A
                    if (p.keyIsDown(65 + 22)) _tm = KSMath.Matrix.multiply(KSMath.Matrix.scale(1, 1.01, 1), _tm);     // S
                    if (p.keyIsDown(65 + 3))  _tm = KSMath.Matrix.multiply(KSMath.Matrix.scale(1.01, 1, 1), _tm);;    // D
                    if (p.keyIsDown(65 + 16)) _tm = KSMath.Matrix.multiply(KSMath.Matrix.rotateZ(0.05), _tm);         // Q
                    if (p.keyIsDown(65 + 4))  _tm = KSMath.Matrix.multiply(KSMath.Matrix.rotateZ(-0.05), _tm);        // E
                    // Reset with R key
                    if (p.keyIsDown(65 + 17)) {
                        _tm = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
                    }
                    if (originalTm != _tm) {
                        KSDom.updateListeners("_tm", KSMath.Matrix.toFixed(_tm, 2));
                    }
                    
                    // Draw axes
                    p.strokeWeight(5);
                    p.stroke(255, 0, 0);
                    p.fill(255); 
                    p.line(-_canvasWidth, 0, 0, _canvasWidth, 0, 0);
                    p.stroke(0, 255, 0);
                    p.line(0, -_canvasWidth, 0, 0, _canvasWidth, 0);
                    
                    // Draw target-box
                    p.push();
                    p.strokeWeight(4);
                    p.noFill();
                    p.stroke(200, 200, 200);
                    p.rotateZ(45);
                    p.scale(1.5, 0.1, 1);
                    p.rotateZ(45);
                    p.box(_canvasWidth / 4);
                    p.pop();
    
                    // Draw control-box
                    p.push();
                    p.strokeWeight(8);
                    p.noFill();
                    p.stroke(0);
                    p.applyMatrix(
                        _tm[0][0], _tm[0][1], _tm[0][2], _tm[0][3],
                        _tm[1][0], _tm[1][1], _tm[1][2], _tm[1][3],
                        _tm[2][0], _tm[2][1], _tm[2][2], _tm[2][3],
                        _tm[3][0], _tm[3][1], _tm[3][2], _tm[3][3],
                    );
                    p.box(_canvasWidth / 4);
                    p.pop();
                }
            }
            new p5(sketch2);

            function sketch3(p) {
                const slider1 = document.getElementById("sketch-3-slide-s1");
                const slider2 = document.getElementById("sketch-3-slide-s2");

                const UV = [
                    [Math.cos(KSMath.toRadians(45)), -Math.sin(KSMath.toRadians(45))], 
                    [Math.sin(KSMath.toRadians(45)), Math.cos(KSMath.toRadians(45))]
                ];

                let S = [[1.5, 0], [0, 0.1]];

                function calculateA() {  
                    return KSMath.Matrix.multiply(KSMath.Matrix.multiply(UV, S), UV); 
                }

                KSDom.updateListeners("s3Sigma", KSMath.Matrix.toFixed(S, 2));
                KSDom.updateListeners("s3A", KSMath.Matrix.toFixed(calculateA(), 2));
                
                slider1.addEventListener('input', () => {
                    S[0][0] = slider1.value / 100 * 1.5;
                    KSDom.updateListeners("s3Sigma", KSMath.Matrix.toFixed(S, 2));
                    KSDom.updateListeners("s3A", KSMath.Matrix.toFixed(calculateA(), 2));
                });

                slider2.addEventListener('input', () => {
                    S[1][1] = slider2.value / 1000;
                    KSDom.updateListeners("s3Sigma", KSMath.Matrix.toFixed(S, 2));
                    KSDom.updateListeners("s3A", KSMath.Matrix.toFixed(calculateA(), 2));
                });

                let _canvasWidth;
    
                p.setup = function() {
                    _canvasWidth = calculateCanvasWidth(p);
                    let canvas = p.createCanvas(_canvasWidth, _canvasWidth * 9/16, p.WEBGL);
                    canvas.parent('sketch-holder-3');
                    p.angleMode(p.DEGREES);
                }
    
                p.windowResized = function() {
                    _canvasWidth = calculateCanvasWidth(p);
                    p.resizeCanvas(_canvasWidth, _canvasWidth * 9/16);
                }

                p.draw = function() {
                    p.background(255);
                    p.ortho();
                    
                    // Draw axes
                    p.strokeWeight(5);
                    p.stroke(255, 0, 0);
                    p.fill(255); 
                    p.line(-_canvasWidth, 0, 0, _canvasWidth, 0, 0);
                    p.stroke(0, 255, 0);
                    p.line(0, -_canvasWidth, 0, 0, _canvasWidth, 0);
                    
                    // Draw target-box
                    p.push();
                    p.strokeWeight(8);
                    p.noFill();
                    p.stroke(0);
                    p.rotateZ(45);
                    p.scale(S[0][0], S[1][1], 1);
                    p.rotateZ(45);
                    p.box(_canvasWidth / 4);
                    p.pop();
                }
            }
            new p5(sketch3);

            function sketch4(p) {
                let _canvasWidth;
                let _pixelWidth;
                let _image = [
                    [0,0,0,0,0,0,0,0,0,0],
                    [0,0,1,1,1,1,1,1,0,0],
                    [0,1,1,1,1,1,1,1,1,0],
                    [1,1,1,0,1,1,0,1,1,1],
                    [1,1,1,1,1,1,1,1,1,1],
                    [1,1,0,1,1,1,1,0,1,1],
                    [1,1,1,0,0,0,0,1,1,1],
                    [0,1,1,1,1,1,1,1,1,0],
                    [0,0,1,1,1,1,1,1,0,0],
                    [0,0,0,0,0,0,0,0,0,0]
                ];

                let { u, v, q } = SVD(_image);
                let s = [];
                for (let y = 0; y < 10; y++) {
                    s.push([]);
                    for (let x = 0; x < 10; x++) {
                        if (x === y) 
                            s[y].push(q[y]);
                        else 
                            s[y].push(0);
                    }
                }
                _image = calculateImage();
                KSDom.updateListeners("s4s", KSMath.Matrix.toFixed(s, 1));

                let compressionQuality = 100;
                KSDom.updateListeners("s4Slider", compressionQuality + "%");

                const slider4 = document.getElementById("sketch-4-slide");

                slider4.addEventListener('input', () => {
                    compressionQuality = slider4.value * 10;
                    for(let i = 0; i < 10; i++) {
                        if (i < slider4.value)
                            s[i][i] = q[i];
                        else 
                            s[i][i] = 0;
                    }
                    _image = calculateImage();
                    KSDom.updateListeners("s4s", KSMath.Matrix.toFixed(s, 1));
                    KSDom.updateListeners("s4Slider", compressionQuality + "%");
                });
    
                p.setup = function() {
                    _canvasWidth = calculateCanvasWidth(p);
                    let canvas = p.createCanvas(_canvasWidth, _canvasWidth * 9/16);
                    _pixelWidth = _canvasWidth * 9/16 / 10;
                    canvas.parent('sketch-holder-4');
                }

                p.windowResized = function() {
                    _canvasWidth = calculateCanvasWidth(p);
                    p.resizeCanvas(_canvasWidth, _canvasWidth * 9/16);
                    _pixelWidth = _canvasWidth * 9/16 / 10;
                }

                p.draw = function() {
                    p.background(255);
                    for (let y = 0; y < 10; y++) {
                        for (let x = 0; x < 10; x++) {
                            p.fill(Math.abs(_image[y][x]) * 255);
                            p.square(x * _pixelWidth, y * _pixelWidth, _pixelWidth);
                        }
                    }
                }

                function calculateImage() {
                    return KSMath.Matrix.toFixed(KSMath.Matrix.multiply(KSMath.Matrix.multiply(u, s), KSMath.Matrix.transpose(v)), 2);
                }
            }
            new p5(sketch4);
        </script>
    </body>
</html>