<!DOCTYPE html>
<html lang="en">
    <head>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.8.0/p5.min.js"></script>
        <meta charset="utf-8" />
    </head>
    <style>
        main {
            font-family: sans-serif;
            font-size: 2.5vh;
            line-height: 4vh;
            margin: 50px;
        }
        h1 {
            line-height: 6vh;
        }
        math {
            font-size: 3vh;
        }
    </style>
    <body>
        <main>
            <h1>Singular Value Decomposition</h1>
            <p>From Wikipedia: "In linear algebra, the <b>singular value decomposition (SVD)</b> is a factorization of a real or complex matrix into a rotation, followed by a rescaling, followed by another rotation."</p>
            <p>In other words, SVD can break any complex matrix into a multiplication of 3 other matrices. If we visualize the original matrix as a linear transformation, we can see it as:</p>
            <math><mrow><mi>A</mi><mo>=</mo><msub><mi>R</mi><mi>2</mi></msub><mo>*</mo><mi>S</mi><mo>*</mo><msub><mi>R</mi><mi>1</mi></msub></mrow></math>
            <p>Here is a little interactive visualization of this observation in action - try and transform the white cube to fit the skewed grey shape.</p>
            <p><b>Press keys WASDQE to rotate, keys 1-6 to scale, and R to reset.</b></p>
            <p><b>Use the mouse to view the canvas at various angles.</b></p>
            <p id="sketch-holder"></p>
            <div>
                <math>
                    <mrow>
                        <mi>A</mi><mo>=</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><mn>{{_tm[0][0]}}</mn></mtd>
                                <mtd><mn>{{_tm[0][1]}}</mn></mtd>
                                <mtd><mn>{{_tm[0][2]}}</mn></mtd>
                                <mtd><mn>{{_tm[0][3]}}</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>{{_tm[1][0]}}</mn></mtd>
                                <mtd><mn>{{_tm[1][1]}}</mn></mtd>
                                <mtd><mn>{{_tm[1][2]}}</mn></mtd>
                                <mtd><mn>{{_tm[1][3]}}</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>{{_tm[2][0]}}</mn></mtd>
                                <mtd><mn>{{_tm[2][1]}}</mn></mtd>
                                <mtd><mn>{{_tm[2][2]}}</mn></mtd>
                                <mtd><mn>{{_tm[2][3]}}</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>{{_tm[3][0]}}</mn></mtd>
                                <mtd><mn>{{_tm[3][1]}}</mn></mtd>
                                <mtd><mn>{{_tm[3][2]}}</mn></mtd>
                                <mtd><mn>{{_tm[3][3]}}</mn></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                    </mrow>
                </math> 
            </div>
            <p>In case you didn't get that, here is the white cube transforming to fit the skewed grey shape by following a sequence of 3 matrix operations.</p>
            <div style="overflow: auto; scrollbar-width: none;">
                <math>
                    <mrow>
                        <mi>A</mi><mo>=</mo><msub><mi>R</mi><mi>2</mi></msub><mo>*</mo><mi>S</mi><mo>*</mo><msub><mi>R</mi><mi>1</mi></msub><mo>=</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><mn>cos(45°)</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>sin(45°)</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>1</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>-sin(45°)</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>cos(45°)</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>1</mn></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                        <mo>*</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><mn>1.3</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0.8</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0.5</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>1</mn></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                        <mo>*</mo>
                        <mo>[</mo>
                        <mtable>
                            <mtr>
                                <mtd><mn>cos(45°)</mn></mtd>
                                <mtd><mn>-sin(45°)</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>sin(45°)</mn></mtd>
                                <mtd><mn>cos(45°)</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>1</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                            </mtr>
                            <mtr>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>0</mn></mtd>
                                <mtd><mn>1</mn></mtd>
                            </mtr>
                        </mtable>
                        <mo>]</mo>
                    </mrow>
                </math> 
            </div>
            <p>Let us not worry about how the factorization into 3 matrices can be done yet. Instead, let us look into why SVD matters - because it exposes some interesting properties that can be used to solve a wide array of different problems!</p>
        </main>
        <script>
            // ==== START OF REACTIVE LIBRARY ====
            let listeners = [];

            document.querySelectorAll('body main *').forEach(element => {
                let rootNode = element.childNodes[0];
                if (!rootNode || !rootNode.nodeValue) return;
                let textContent = rootNode.textContent.trim();
                if (textContent.includes("\{\{") && textContent.includes("}}")) {
                    var variables = getHTMLInLineVariables(textContent);
                    if (variables.length === 0) return;
                    variablesValues = [];
                    variables.forEach(variable => variablesValues[variable] = undefined);
                    listeners.push({ element: rootNode, content: textContent, variables: variablesValues });
                }
            });

            function getHTMLInLineVariables(str) 
            { 
                let result = [];
                let openBracesIndex = -1;
                for(let i = 0; i < str.length; i++) { 
                    // If opening delimiter is encountered 
                    if (str.substring(i, i + 2) === "\{\{" && openBracesIndex === -1)
                        openBracesIndex = i;
                    // If closing delimiter is encountered 
                    else if (str.substring(i, i + 2) === "}}" && openBracesIndex > -1) {
                        let substring = str.substring(openBracesIndex + 2, i);
                        result.push(substring);
                        openBracesIndex = -1;
                    } 
                }
                return result;
            }

            function updateListeners(variableName, newValue) {
                let updatedListeners = [];
                listeners.forEach(listener => {
                    let isUpdated = false;
                    Object.keys(listener.variables).forEach(variableKey => {
                        let value = structuredClone(newValue);
                        let keysArray = getKeysArray(variableKey.trim());
                        if (keysArray[0] === variableName) {
                            if (keysArray.length > 1)
                                for(let i = 1; i < keysArray.length; i++)
                                    value = value[keysArray[i]];
                            isUpdated = true;
                            listener.variables[variableKey] = value;
                        }
                    });
                    if (isUpdated)
                        updatedListeners.push(listener);
                });
                updatedListeners.forEach(listener => {
                    let textContent = listener.content;
                    Object.keys(listener.variables).forEach(variableKey =>
                        textContent = textContent.replaceAll("\{\{" + variableKey + "}}", listener.variables[variableKey])
                    );
                    listener.element.textContent = textContent;
                });
            }

            function getKeysArray(str) {
                let results = [];
                let values = str.split(".");
                values.forEach(val => {
                    if (!val.includes("[")) results.push(val);
                    else val.split("[").forEach(val => results.push(val.replace("]", "")));
                });
                return results;
            }
            // ==== END OF REACTIVE LIBRARY ====

            let _canvasWidth;
            let _tm = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]; // "transform matrix"

            updateListeners("_tm", fixDecimalPlaces(_tm, 2));

            function setup() {
                _canvasWidth = windowHeight > windowWidth ? windowWidth / 1.15 : windowWidth / 2;
                let canvas = createCanvas(_canvasWidth, _canvasWidth * 9/16, WEBGL);
                canvas.parent('sketch-holder');
                angleMode(DEGREES);
            }

            function windowResized() {
                _canvasWidth = windowHeight > windowWidth ? windowWidth / 1.25 : windowWidth / 2;
                resizeCanvas(_canvasWidth, _canvasWidth * 9/16);
            }

            function draw() {
                background(0);
                
                // Call every frame to adjust camera based on mouse/touch
                orbitControl();
                rotateX(-25);
                rotateY(-10);
                
                // Handle controls
                let originalTm = _tm;
                if (keyIsDown(65 + 18)) _tm = matrixMult(xRotMatrix(2), _tm);           // W
                if (keyIsDown(65))      _tm = matrixMult(yRotMatrix(2), _tm);           // A
                if (keyIsDown(65 + 22)) _tm = matrixMult(xRotMatrix(-2), _tm);          // S
                if (keyIsDown(65 + 3))  _tm = matrixMult(yRotMatrix(-2), _tm);          // D
                if (keyIsDown(65 + 16)) _tm = matrixMult(zRotMatrix(2), _tm);           // Q
                if (keyIsDown(65 + 4))  _tm = matrixMult(zRotMatrix(-2), _tm);          // E
                if (keyIsDown(49))  _tm = matrixMult(scaleMatrix(0.989, 1, 1), _tm);    // 1
                if (keyIsDown(50))  _tm = matrixMult(scaleMatrix(1.01, 1, 1), _tm);     // 2
                if (keyIsDown(51))  _tm = matrixMult(scaleMatrix(1, 0.989, 1), _tm);    // 3
                if (keyIsDown(52))  _tm = matrixMult(scaleMatrix(1, 1.01, 1), _tm);     // 4
                if (keyIsDown(53))  _tm = matrixMult(scaleMatrix(1, 1, 0.989), _tm);    // 5
                if (keyIsDown(54))  _tm = matrixMult(scaleMatrix(1, 1, 1.01), _tm);     // 6
                // Reset with R key
                if (keyIsDown(65 + 17)) {
                    _tm = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
                    setup();
                }
                if (originalTm != _tm) {
                    updateListeners("_tm", fixDecimalPlaces(_tm, 2));
                }
                
                // Draw axes
                strokeWeight(1);
                stroke(255, 0, 0);
                fill(255); 
                line(-_canvasWidth, 0, 0, _canvasWidth, 0, 0);
                stroke(0, 255, 0);
                line(0, -_canvasWidth, 0, 0, _canvasWidth, 0);
                stroke(0, 0, 255);
                line(0, 0, -_canvasWidth, 0, 0, _canvasWidth);
                
                // Draw target-box
                push();
                strokeWeight(1);
                noFill();
                stroke(111, 111, 111);
                rotateZ(45);
                scale(1.3, 0.8, 0.5);
                rotateY(45);
                box(_canvasWidth / 5);
                pop();

                // Draw control-box
                push();
                strokeWeight(2);
                noFill();
                stroke(255, 255, 255);
                applyMatrix(
                    _tm[0][0], _tm[0][1], _tm[0][2], _tm[0][3],
                    _tm[1][0], _tm[1][1], _tm[1][2], _tm[1][3],
                    _tm[2][0], _tm[2][1], _tm[2][2], _tm[2][3],
                    _tm[3][0], _tm[3][1], _tm[3][2], _tm[3][3],
                );
                box(_canvasWidth / 5);
                pop();
            }

            // ==== START OF MATRIX LIBRARY ====

            function xRotMatrix(th) {
                return [
                    [1,     0,          0,          0],
                    [0,     cos(th),    -sin(th),   0],
                    [0,     sin(th),    cos(th),    0],
                    [0,     0,          0,          1]
                ];
            }

            function yRotMatrix(th) {
                return [
                    [cos(th),   0,      sin(th),    0],
                    [0,         1,      0,          0],
                    [-sin(th),  0,      cos(th),    0],
                    [0,         0,      0,          1]
                ];
            }

            function zRotMatrix(th) {
                return [
                    [cos(th),   -sin(th),   0,      0],
                    [sin(th),   cos(th),    0,      0],
                    [0,         0,          1,      0],
                    [0,         0,          0,      1]
                ];
            }

            function scaleMatrix(x, y, z) {
                return [
                    [x, 0, 0, 0], 
                    [0, y, 0, 0], 
                    [0, 0, z, 0], 
                    [0, 0, 0, 1]
                ];
            }

            function matrixMult(A, B) {
                if(A[0].length !== B.length) 
                    return "A col != B row"

                l = A.length;      // Number of rows in A
                m = A[0].length;   // Number of columns in A and number of rows in B
                n = B[0].length;   // Number of columns in B
                
                let C = []

                for(let i = 0; i < l; i++){
                    C[i] = [];
                    for(let j = 0; j < n; j++){
                        C[i][j] = [];
                    }
                }
                
                for(let row = 0; row < l ; row++){
                    for(let col = 0; col < n; col++){
                        let v = [];
                        let w = [];
                        for(let i = 0; i < m ; i++) {
                            v.push(A[row][i])
                            w.push(B[i][col])
                        }
                        C[row][col] = dotProduct(v,w)
                    }
                }
                return C;
            }

            function dotProduct(v, w) {
                let sum = 0;
                for (let i = 0; i < v.length; i++)
                    sum += v[i] * w[i];
                return sum;
            }

            function fixDecimalPlaces(mat, places) {
                let result = [];
                for(let row = 0; row < mat.length ; row++) {
                    result[row] = [];
                    for(let col = 0; col < mat[0].length; col++) {
                        result[row][col] = mat[row][col];
                        result[row][col] = result[row][col].toFixed(2);
                    }
                }    
                return result;
            }

            // ==== END OF MATRIX LIBRARY ====
        </script>
    </body>
</html>